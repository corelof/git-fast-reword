# git-fast-reword

### Задача
Дан набор пар (хэш, новое имя). Перестроить граф коммитов в текущем репозиторий таким образом, чтобы сохранить структуру, но изменить сообщения коммитов. Опустим простые улучшения(которые реализованны, но их написание достаточно тривиально), такие как получение позиции относительно HEAD вместо хэша, работа с файлом в формате 'хэш новое_сообщение'.

### Тривиальное решение
Выделить из git-репозитория граф коммитов, с которым можно будет легко работать. Для этого нужно обнаружить все вершины со степенью вхождения 0 и запустить из каждой обход графа. Для обнаружения таких вершин просто обойдем все локальные ветви, аннотированные и легковесные теги. Также не стоит забывать про HEAD, т.к. репозиторий может быть в состоянии detached head. Запустим обход из каждой вершины, таким образом мы соберем весь граф коммитов. Далее, собрав граф(на данном этапе это уже объект в памяти), еще раз обходим его и меняем сообщения необходимых коммитов на нужные. Топологически сортируем полученный граф, получаем некоторый порядок его обхода. Следуя данному порядку создаем новые коммиты, в качестве параметров берем все старые параметры, за исключением сообщения. В конце изменяем указатели веток и тегов если требуется, не забываем про detached head. Перед окончанием запускаем git garbage collector, чтобы удалить ненужные коммиты.
Такое решение не является оптимальным, ведь изменение любого сообщения требует ровно O(commits_in_repo_amount) изменений коммитов, а это непозволительно долго в случае с большими репозиториями.

### Идеи по оптимизации
Стоит заметить, что до этапа топологической сортировки не обязательно доводить весь граф. Есть коммиты такие, что из них не достижим ни один из изменяемых коммитов. Такие коммиты в графе держать не стоит.
1. Стоит заметить, что у каждого коммита есть время его создания. Мы можем использовать это для того, чтобы еще на первом этапе не посещать "неинтересные" коммиты. Однако git легко позволяет создать ситуацию, когда `creationTime(parent).after(creationTime(child)) == true`, так что я добавил эту оптимизацию как опциональную, включается она при флаге `-date-optimization`.
2. Даже после отсечения слишком ранних коммитов, в графе все еще остаются такие вершины, из которых нельзя достичь ни одну из изменяемых(т.е. после перестроения их хэш останется прежним). Чтобы отсечь их, запустим серию обходов из "листьев" текущего графа: идем вверх по childам и останавливаемся если переименовываем вершину, иначе удаляем текущую вершину, поднимаемся из нее выше если сообщение следующей вершины не будет изменено и мы ее единственный оставшийся parent.
3. В оставшемся графе будут такие вершины, что хотя бы один из их parentов мы удалили, но он нужен нам для корректного построения коммита, восстановим недостающих parentов с пометкой о том, что делать их rebuild мы не будем.

Эти оптимизации помогут довести до этапа топологической сортировки минимально возможный граф и работать с ним.

### Ошибочные оптимизации
Я столкнулся с двумя идеями, только после реализации которых я понял их некорректность:
1. Заканчивать сбор начального графа, когда мы собрали все вершины, которые будем переименовывать: мы можем получить несвязный граф и все пойдет не так, как хотелось бы
2. Использовать СНМ для проверки на связность, заканчивать после того как все связалось в одну компоненту: говорить о связности в данном графе некорректно, однако может показаться что для СНМ можно назвать ребра неориентированными, но в особом случае мы все так же будем получать граф, который потерял несколько ребер, что недопустимо.

Для упрощения процесса разработки я написал несложные unit-тесты, которые покрывают все очевидные неприятные ситуации в репозиториях, они описаны в `init_repo/`, их запуск производится в travis-ci, там же есть тестовый запуск прямо на intellij-community репозитории. Как видно, случайный [коммит](https://github.com/JetBrains/intellij-community/commit/5d2dfa41c046ce288f1aaddb243aa364aef043db) из мастера утилита обновляет довольно быстро, время перестроения ~115000 коммитов составляет ~21 секунду. Это кажется более чем достаточным результатом, достигается он по большей части засчет того, что мы никак не затрагиваем работу с индексируемыми файлами, деревьями, их сравнением и т.д.
